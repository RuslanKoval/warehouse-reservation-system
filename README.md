# Warehouse Reservation System (Laravel)

## Overview
Цей проект реалізує **спрощену подієво-орієнтовану систему резервування складу** за допомогою Laravel.  
Система обробляє такі робочі процеси:
- Створення замовлення
- Резервування інвентарю
- Інтеграцію з постачальником
- Підтвердження затримки доставки через асинхронні завдання

### Основні принципи
- **Подієво-орієнтована архітектура**
- **Асинхронна обробка**
- **Завдання, що підтримують ідемпотентність і повторюваність**
- **Прозорий стан замовлення**

---

## Опис потоку подій

### 1. Створення замовлення
- **Endpoint:**
  ```
  POST /api/order
  ```

- **Потік:**
    1. Клієнт надсилає `sku` та `qty`.
    2. Система створює **Order** зі статусом `pending`.
    3. Емітується подія `OrderCreated`.
    4. Слухач події запускає завдання `ReserveInventoryJob`.

---

### 2. Резервування інвентарю (Асинхронне завдання)
- **Завдання:** `ReserveInventoryJob`

- **Потік:**
    - Завдання виконується в рамках транзакції БД:
        1. Рядок інвентарю блокується через `SELECT ... FOR UPDATE`.
        2. **Якщо запасів достатньо:**
            - Кількість інвентарю зменшується.
            - Створюється запис про рух інвентарю.
            - Статус замовлення → `reserved`.
        3. **Якщо запасів недостатньо:**
            - Відправляється запит резервування до постачальника.
            - Статус замовлення → `awaiting_restock`.
            - Зберігається посилання на постачальника.
            - Завдання `CheckSupplierStatusJob` переноситься на **15 секунд**.

---

### 3. Інтеграція з постачальником
- **Endpoint резервування:**
  ```
  POST /supplier/reserve
  ```

- **Приклад відповіді:**
  ```json
  { "accepted": true, "ref": "1234" }
  ```

- **Примітки:**
    - `accepted = true` не гарантує фактичної доставки.
    - Інтеграція емулюється за допомогою `Http::fake()` для тестування й ізоляції.

---

### 4. Перевірка статусу постачальника (Відкладене завдання)
- **Завдання:** `CheckSupplierStatusJob`

- **Потік:**  
  Завдання перевіряє статус постачальника за посиланням:
    - Можливі відповіді:
        - `ok` → Статус замовлення → `reserved`
        - `fail` → Статус замовлення → `failed`
        - `delayed` → Повторна перевірка через **15 секунд**

    - **Максимум повторів для `delayed`:** 2  
      Після 2 спроб → Статус замовлення → `failed`.

---

### 5. Endpoint'и для читання
- **Деталі замовлення та його статус:**
  ```
  GET /api/orders/{id}
  ```

- **Історія руху інвентарю:**
  ```
  GET /api/inventory/{sku}/movements
  ```

---

## Стратегія обробки помилок

### 1. Ізоляція асинхронних помилок
- Складна бізнес-логіка виконується в **завданнях черги**.
- Помилки **не** блокують HTTP-запити.
- Для обробки тимчасових збоїв використовується механізм повторів у черзі.

### 2. Консистентність бази даних
- Резервування інвентарю виконується в рамках транзакції БД.
- Для уникнення змагання використовується блокування рядків (`lockForUpdate`).
- Рухи інвентарю записуються атомарно зі зміною запасу.

### 3. Збої зовнішніх сервісів
- Інтеграція з постачальником обробляється як **зрештою консистентна**.
- Немає припущення, що `accepted = true` гарантує доставку.
- Затримані відповіді повторюються із **затримкою в 15 секунд**.
- Жорстка зупинка після досягнення максимального числа повторів.

### 4. Ідемпотентність
- Перехід статусу замовлення контролюється явно.
- Завдання можна повторювати без дублювання рухів інвентарю.
- Логіка переходу стану запобігає подвійному резервуванню.

---

## Покращення для продакшн-оточення

### 1. Архітектура та доменний шар
- Впровадити прозору **State Machine** для управління статусами замовлень.
- Винести бізнес-логіку з завдань у **доменні сервіси**.

### 2. Масштабування та надійність
- Використовувати **Redis queue driver**.
- Додати **dead-letter queue** для невдалих завдань.
- Застосувати **експоненційне збільшення затримки** замість фіксованої.

### 3. Спостережуваність
- Додати **структуровані логи** для кожного переходу стану.
- Використовувати **distributed tracing** для асинхронних потоків.
- Відстежувати метрики:
    - Відсоток успіху резервувань
    - Затримки постачальника
    - Кількість повторів завдань

### 4. Безпека та надійність APIs
- Лімітування швидкості запитів для створення замовлення.
- Додати **аутентифікацію** та **авторизацію**.
- Валідувати SKU через довідник.

---

## Резюме
Цей проект демонструє:
- **Архітектуру Laravel на основі подій**
- **Дизайн асинхронного робочого процесу**
- **Безпечне резервування інвентарю при конкуренції**
- **Роботу з ненадійними зовнішніми системами**

Поточна реалізація вже фокусується на коректності та розширюваності, а запропоновані покращення забезпечать стабільність під реальним навантаженням.